<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            /* 
            所谓的算法,本质就是提高计算机程序执行效率,设定的特定的程序
            eg: 求1-100所有偶数的和
            冒泡排序算法: 实现数组数据的重新排序
                1.核心原理
                    a.当前单元和下一个单元的数据进行比较
                    正确的排序顺序,当前单元存储的数据应该小于等于下一个单元存储的数据
                    如果 当前单元存储的数据 小于 下一个单元存储的数据,就需要交换两个单元存储的数据
                    b.如果当前单元存储的数据 大于等于 下一个单元存储的数据;就比较 下一个单元和下下个单元存储的数据
                    这样执行一次循环,可以比较出一个最大值

        */
            // 创建一个数组
            let arr = [1, 5, 4, 8, 97, 5, 6, 6]
            // 那样的内循环,循环一次就可以将一个最大的数放在后面,所以就循环arr.length - 1 - 1次就可以了
            // 为什么要多减一个1,那是因为最后比较arr.length - 1次之后,最后一个数一定是最小的,不用再比较了
            for (let j = 0; j <= arr.length - 1 - 1; j++) {
                // 内部循环,将数组的数据从头到尾循环一遍.前一个元素和后一个元素进行比较,如果前一个元素大于后一个元素的话,就将两个数的位置交换;如果前一个元素没有大于后一个元素的话,那么这两个数的位置就不用交换.
                // 这样的一次循环,就可以把里面最大的一个数放在数组的最后一个位置
                // 这里可以进行一次优化,i <= arr.length - 1 - 1; 因为这个数组的最后一位是arr.length - 1,再循环的之后只用循环到arr.length - 1 - 1,这样在if判断比较arr[i] > arr[i + 1]的时候,arr[i + 1]就不会超出数组长度
                // 内循环这里还可以再进行一次优化,arr.length - 1 - 1 - j,因为外循环一次,就已经定了一个最大的数,再次进入内循环的时候,就少循环一次就行了
                for (var i = 0; i <= arr.length - 1 - 1 - j; i++) {
                    if (arr[i] > arr[i + 1]) {
                        let num = arr[i + 1]
                        arr[i + 1] = arr[i]
                        arr[i] = num
                    }
                }
            }
            console.log(arr)
        </script>
    </body>
</html>
